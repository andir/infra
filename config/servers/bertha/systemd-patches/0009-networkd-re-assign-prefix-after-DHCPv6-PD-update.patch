From 5c7d0b872357b468f93ff84f5486671164f8e263 Mon Sep 17 00:00:00 2001
From: Andreas Rammhold <andreas@rammhold.de>
Date: Tue, 2 Jun 2020 12:05:33 +0200
Subject: [PATCH 9/9] networkd: re-assign prefix after DHCPv6 PD update
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Previously on a lease update/renewal prefixes would not be announced by
radv anymore. Since PD prefixes can have a very long lifetime
(days/weeks/â€¦) that issue wasn't really obvious in the previous (manual)
tests.

Instead of bailing out whenever there is already a PD prefix configured
on the interface we now let the code continue to re-assign the prefix as
long as it is the same prefix (as before).
---
 src/network/networkd-dhcp6.c | 24 ++++++++++++++----------
 1 file changed, 14 insertions(+), 10 deletions(-)

diff --git a/src/network/networkd-dhcp6.c b/src/network/networkd-dhcp6.c
index 235689e30f..b344dfa114 100644
--- a/src/network/networkd-dhcp6.c
+++ b/src/network/networkd-dhcp6.c
@@ -25,7 +25,7 @@ static int dhcp6_lease_address_acquired(sd_dhcp6_client *client, Link *link);
 static Link *dhcp6_prefix_get(Manager *m, struct in6_addr *addr);
 static int dhcp6_prefix_add(Manager *m, struct in6_addr *addr, Link *link);
 static int dhcp6_prefix_remove_all(Manager *m, Link *link);
-static bool dhcp6_link_has_dhcpv6_prefix(Link *link);
+static bool dhcp6_link_get_dhcpv6_prefix(Link *link, struct in6_addr *out);
 static int dhcp6_assign_delegated_prefix(Link *link, const struct in6_addr *prefix,
                                          uint8_t prefix_len,
                                          uint32_t lifetime_preferred,
@@ -301,6 +301,7 @@ static int dhcp6_pd_prefix_distribute(Link *dhcp6_link,
 
         HASHMAP_FOREACH(link, manager->links, i) {
                 union in_addr_union assigned_prefix;
+                struct in6_addr current_prefix;
 
                 if (link == dhcp6_link)
                         continue;
@@ -310,12 +311,6 @@ static int dhcp6_pd_prefix_distribute(Link *dhcp6_link,
 
                 log_link_debug(link, "Searching for a suitable prefix");
 
-                if (dhcp6_link_has_dhcpv6_prefix(link)) {
-                        log_link_debug(link, "Already has a prefix. Skipping.");
-                        continue;
-                }
-
-
                 if (assign_preferred_subnet_id != dhcp6_has_preferred_subnet_id(link)) {
                         log_link_debug(link, "Skipping prefix search as this isn't the mode we are looking for");
 
@@ -336,6 +331,12 @@ static int dhcp6_pd_prefix_distribute(Link *dhcp6_link,
                 } else if (r < 0)
                         return r;
 
+                if (dhcp6_link_get_dhcpv6_prefix(link, &current_prefix))
+                        if (!in_addr_equal(AF_INET6, (union in_addr_union *)&current_prefix, &assigned_prefix)) {
+                                log_link_debug(link, "Link already has another DHCPv6 prefix assigned.");
+                                continue;
+                        }
+
                 (void) in_addr_to_string(AF_INET6, &assigned_prefix, &assigned_buf);
                 r = dhcp6_pd_prefix_assign(link, &assigned_prefix.in6, 64,
                                            lifetime_preferred, lifetime_valid);
@@ -984,16 +985,19 @@ static int dhcp6_prefix_remove_all(Manager *m, Link *link) {
         return 0;
 }
 
-static bool dhcp6_link_has_dhcpv6_prefix(Link *link) {
+static bool dhcp6_link_get_dhcpv6_prefix(Link *link, struct in6_addr *out) {
+        struct in6_addr *addr;
         Iterator i;
         Link *l;
 
         assert(link);
         assert(link->manager);
 
-        HASHMAP_FOREACH(l, link->manager->dhcp6_prefixes, i)
-                if (link == l)
+        HASHMAP_FOREACH_KEY(l, addr, link->manager->dhcp6_prefixes, i)
+                if (link == l) {
+                        *out = *addr;
                         return true;
+                }
 
         return false;
 }
-- 
2.26.2

